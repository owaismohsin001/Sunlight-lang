type Maybe <- Some{a} | None

seq ? f@Some and a@Some -> some: f.a: a.a
seq ? f@None or a@None -> a

unit ? r@Maybe -> some: s

bind ? s@Some -> f: s.a
bind ? s@None -> None

class getSome: mb, d
mb@Some -> mb.a;
mb@None -> d;

fmap ? xs@Some -> some: f: xs.a
fmap ? xs@None -> None

glance ? s@Some -> some: glance: fi, i, s.a
glance ? s@None -> None

access ? s@Some -> i access s.a
access ? s@None -> None

empty ? ls@Some -> empty: ls.a

unedit ? s@Some -> some: unedit: s.a, i, fi, uf
unedit ? s@None -> None

class toEither: s
s@Some -> right: s.a
s@None -> left: ()

type Either <- Right{r} | Left{l}

class getRight: et, d
et@Right -> et.a
et@Left -> d

class getLeft: et, d
et@Right -> d
et@Left -> et.l;

fmap ? xs@Right -> f: xs.r
fmap ? xs@Left -> xs

unit ? r@Either -> right: s

bind ? s@Left -> s.l
bind ? s@Right -> f: s.r

seq ? f@Right and a@Right -> right: f.r: a.r
seq ? f@Left and a@Left -> left: f.l: a.l
seq ? f@Left or a@Right -> a

unedit ? s@Right -> right: unedit: s.r, i, fi, uf
unedit ? s@Left -> left: unedit: s.l, i, fi, uf

glance ? s@Right -> right: glance: fi, i, s.r
glance ? s@Left -> left: glance: fi, i, s.l

access ? s@Right -> i access s.r
access ? s@Left -> i access s.l

empty ? ls@Right -> empty: ls.r
empty ? ls@Left -> empty: ls.l
